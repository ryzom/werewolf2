global proc extrudeFirewood() {
string $selected[] = `ls -sl`;
for($select in $selected) {
	string $face = $select + ".f[0]";
	$numsteps = floor(rand(1, 5.99));
	$length = rand(4.5, 6.5);
	$remaining = $length;
	float $lastx = 0.0;
	float $lastz = 0.0;
	for($i = 0; $i < $numsteps; $i++) {
		$step = $length/$numsteps + rand(-1, 1);
		if($i == ($numsteps - 1)) {
			$step = $remaining;
		} else {
			$remaining -= $step;
		}
		$lastx += rand(-0.2, 0.2);
		$lastz += rand(-0.2, 0.2);
		polyExtrudeFacet -ch 1 -kft 1 -pvx 5.553833961 -pvy 0 -pvz 9.107969284 -tx $lastx -ty $step -tz $lastz -rx 0 -ry 0 -rz 0 -sx 1 -sy 1 -sz 1 -ran 0 -divisions 1 -twist 0 -taper 1 -off 0 -ltz 0 -ws 0 -ltx 0 -lty 0 -lrx 0 -lry 0 -lrz 0 -lsx 1 -lsy 1 -lsz 1 -ldx 1 -ldy 0 -ldz 0 -w 0 -gx 0 -gy -1 -gz 0 -att 0 -mx 0 -my 0 -mz 0 -sma 30 $face;
	}
}
}

global proc createDdsMaterial(string $texture) {
	$selection = `ls -sl`;
	$AEpopup = `optionVar -q AEpopupWhenCreatingShaders`;
	optionVar -intValue AEpopupWhenCreatingShaders 0;
	int $first = true;
	string $sh[];
	for($select in $selection) {
		if($first) {
			createAndAssignShader lambert $select;
			$sh = `listRelatives -s -pa -ni $select`;
			int $instanceIndex;
			$instanceParents = `listRelatives -ap -pa $sh`;
			int $i;
			for($i = 0; $i < `size($instanceParents)`; $i++) {
				if($instanceParents[$i] == $select) {
					$instanceIndex = $i;
				}
			}
			$sh = `listConnections ($sh[0] + ".instObjGroups[" + $instanceIndex + "]")`;
			$sh = `listConnections ($sh[0] + ".surfaceShader")`;
			$sh[0] = `rename $sh[0] "dds_material"`;
			$tex = `shadingNode -asTexture file`;
			$place = `shadingNode -asUtility place2dTexture`;
			connectAttr -f ($place + ".coverage") ($tex + ".coverage");
			connectAttr -f ($place + ".translateFrame") ($tex + ".translateFrame");
			connectAttr -f ($place + ".rotateFrame") ($tex + ".rotateFrame");
			connectAttr -f ($place + ".mirrorU") ($tex + ".mirrorU");
			connectAttr -f ($place + ".mirrorV") ($tex + ".mirrorV");
			connectAttr -f ($place + ".stagger") ($tex + ".stagger");
			connectAttr -f ($place + ".wrapU") ($tex + ".wrapU");
			connectAttr -f ($place + ".wrapV") ($tex + ".wrapV");
			connectAttr -f ($place + ".repeatUV") ($tex + ".repeatUV");
			connectAttr -f ($place + ".offset") ($tex + ".offset");
			connectAttr -f ($place + ".rotateUV") ($tex + ".rotateUV");
			connectAttr -f ($place + ".noiseUV") ($tex + ".noiseUV");
			connectAttr -f ($place + ".vertexUvOne") ($tex + ".vertexUvOne");
			connectAttr -f ($place + ".vertexUvTwo") ($tex + ".vertexUvTwo");
			connectAttr -f ($place + ".vertexUvThree") ($tex + ".vertexUvThree");
			connectAttr -f ($place + ".vertexCameraOne") ($tex + ".vertexCameraOne");
			connectAttr ($place + ".outUV") ($tex + ".uv");
			connectAttr ($place + ".outUvFilterSize") ($tex + ".uvFilterSize");
			connectAttr -force ($tex + ".outColor") ($sh[0] + ".color");
			AEassignTextureCB  ($tex + ".fileTextureName") ("textures/" + $texture) "image";
			$first = false;
		} else {
			assignSG $sh[0] $select;
		}
	}
	optionVar -intValue AEpopupWhenCreatingShaders $AEpopup;
}

global proc createPsdMaterial(string $texture) {
	$selection = `ls -sl`;
	$AEpopup = `optionVar -q AEpopupWhenCreatingShaders`;
	optionVar -intValue AEpopupWhenCreatingShaders 0;
	int $first = true;
	string $sh[];
	for($select in $selection) {
		if($first) {
			createAndAssignShader lambert $select;
			$sh = `listRelatives -s -pa -ni $select`;
			int $instanceIndex;
			$instanceParents = `listRelatives -ap -pa $sh`;
			int $i;
			for($i = 0; $i < `size($instanceParents)`; $i++) {
				if($instanceParents[$i] == $select) {
					$instanceIndex = $i;
				}
			}
			$sh = `listConnections ($sh[0] + ".instObjGroups[" + $instanceIndex + "]")`;
			$sh = `listConnections ($sh[0] + ".surfaceShader")`;
			$sh[0] = `rename $sh[0] "psd_material"`;
			$tex = `shadingNode -asTexture psdFileTex`;
			$place = `shadingNode -asUtility place2dTexture`;
			connectAttr -f ($place + ".coverage") ($tex + ".coverage");
			connectAttr -f ($place + ".translateFrame") ($tex + ".translateFrame");
			connectAttr -f ($place + ".rotateFrame") ($tex + ".rotateFrame");
			connectAttr -f ($place + ".mirrorU") ($tex + ".mirrorU");
			connectAttr -f ($place + ".mirrorV") ($tex + ".mirrorV");
			connectAttr -f ($place + ".stagger") ($tex + ".stagger");
			connectAttr -f ($place + ".wrapU") ($tex + ".wrapU");
			connectAttr -f ($place + ".wrapV") ($tex + ".wrapV");
			connectAttr -f ($place + ".repeatUV") ($tex + ".repeatUV");
			connectAttr -f ($place + ".offset") ($tex + ".offset");
			connectAttr -f ($place + ".rotateUV") ($tex + ".rotateUV");
			connectAttr -f ($place + ".noiseUV") ($tex + ".noiseUV");
			connectAttr -f ($place + ".vertexUvOne") ($tex + ".vertexUvOne");
			connectAttr -f ($place + ".vertexUvTwo") ($tex + ".vertexUvTwo");
			connectAttr -f ($place + ".vertexUvThree") ($tex + ".vertexUvThree");
			connectAttr -f ($place + ".vertexCameraOne") ($tex + ".vertexCameraOne");
			connectAttr ($place + ".outUV") ($tex + ".uv");
			connectAttr ($place + ".outUvFilterSize") ($tex + ".uvFilterSize");
			connectAttr -force ($tex + ".outColor") ($sh[0] + ".color");
			AEassignTextureCB  ($tex + ".fileTextureName") ("textures/" + $texture) "Photoshop";
			setAttr -type "string" ($tex + ".layerSetName") "Main";
			$first = false;
		} else {
			assignSG $sh[0] $select;
		}
	}
	optionVar -intValue AEpopupWhenCreatingShaders $AEpopup;
}

/////////////////////////////////
// MUSINGS
/////////////////////////////////

Property connections:
	* fast random removes
	* fast adds to the end
	* both connection sides know about each other
	* type checking

We want to be able to access properties in scripts.
	Syntax:
		1) dataContainer.property
		2) sob.dataContainer.property

Dynamic access to IProperty objects via a name.

container.property is related to permissions (roles that can access the property).


/////////////////////////////////
// IDEAS
/////////////////////////////////
Idea 1.
	Dirty propagation. This saves computation time, since connections are traversed and values calculated only if asked for.
	This requires a node based architecture with a definite interface for value calculation.
	
	Is a node based architecture possible?
		* what changes values?
		* how are values calculated based on other values?
			1) direct connections.
			2) ???
			...
		* examples? UCs?
		* how does this fit in with controllers, handlers, views and stuff?

	Requires some sort of IInput class and IProperty of course. CProperty<T> is the implementation of IProperty. And IDirtyListener or something like that.
	IProperty 1->* IDirtyPropagator 1->* IDirtyPropagator
	
	For media the first DirtyPropagator is the "input"....should really be called something else - Specific cases are mesh selection, texture selection, animation triggering and morphing. A common base class would be needed. They look like media controllers.
	The next DirtyPropagators are meshes, mesh groups, animation groups and the EMD itself.
	IProperty extends IDirtyPropagator.
	IDirtyPropagator has pointers to input and output datastructures. These are initialized only if an input or output connection is made. So for example IProperty might never have an input connection, so no extra space is taken up by the datastructure to keep input connections.

class IDirtyPropagator {
public:
	typedef struct {
		IDirtyPropagator*	Propagator;
		uint32			ID;
	} TConnection;
	typedef std::vector<TConnection> TConList;

	bool		isDirty();

	void		setDirty();
	void		setClean();

	uint32		makeInputConnection(IDirtyPropagator* input);

	void		breakInputConnection(uint32 id);
	void		breakInputConnection(IDirtyPropagator* input);

	void		breakOutputConnection(uint32 id);
	void		breakOutputConnection(IDirtyPropagator* output);	
	
private:
	friend class IDirtyPropagator;

	void		killInputConnection(uint32 id);
	void		killOutputConnection(uint32 id);
	TConnection*	makeOutputConnection(IDirtyPropagator* output);
	void		propagateDirtyState();

	bool		m_Dirty;

	TConList*	m_Inputs;
	TConList*	m_Outputs;
};

	Are affects relationships required? Or does any dirty input on a node automatically set all the outputs dirty?

Idea 2.
	Change listeners. This is slower because every change triggers a recalculation of the values. Maybe could use sigc++.

/////////////////////////////////
// UCs
/////////////////////////////////

UC 1. Morphs based on a property value. (Fat guy)
UC 2. Mesh selection based on properties. (Apple that has been taken a bite out of)
UC 3. Mesh selection based on properties and morph. (Fat guy with shirt on)
UC 4. Texture selection based on properties (Rotting apple)
UC 5. State based animations. (Run)


/////////////////////////////////
// UC Implementations
/////////////////////////////////
UC 1 @ Idea 1
	1. torso mesh group update()
		1.1. if(visible)
		1.2. if(dirty)
		1.3. mesh update()
			1.3.1 if(dirty)
			1.3.2 fatMorphInput update()
				1.3.2.1 if(dirty)
1.3.2.2 SOB.getProperty("fat").getValue()
1.3.2.3 calculate morph factor
1.3.2.4 instance.setBlendShapeFactor()
				1.3.2.5 setClean()
			1.3.3 setClean()
		1.4 setClean()

UC 2 @ Idea 1
	1. main mesh group update()
		1.1 if(visible)
		1.2 if(dirty)
		1.3 meshSelectorInput update()
			1.3.1 if(dirty)
			1.3.2 SOB.getProperty("amount").getValue()
			1.3.3 calculate mesh to select
			1.3.4 select mesh to display
			1.3.5 setClean()
		1.4 setClean()

UC 2 @ Idea 1
	1. torso mesh group update()
		1.1 if(visible)
		1.2 if(dirty)
		1.3 meshSelectorInput update()
			1.3.1 if(dirty)
			1.3.2 SOB.getProperty("waistSize").getValue() etc...
			1.3.3 calculate mesh to select
			1.3.4 select mesh to display
			1.3.5 setClean()
		1.4. mesh update()
			1.4.1 if(dirty)
			1.4.2 fatMorphInput update()
				1.4.2.1 if(dirty)
				1.4.2.2 SOB.getProperty("fat").getValue()
				1.4.2.3 calculate morph factor
				1.4.2.4 instance.setBlendShapeFactor()
				1.4.2.5 setClean()
			1.4.3 setClean()
		1.5 setClean()

UC 3 Idea @ Idea 1
	1. mesh group update()
		1.1 if(visible)
		1.2 if(dirty)
		1.3 update inputs
			1.3.1 if(dirty)
			1.3.2 get properties
			1.3.3 do stuff
			1.3.4 setClean()
		1.4. update mesh
			1.4.1 if(dirty)
			1.4.2 update inputs
			1.4.3 setClean()
		1.5 setClean()

UC 4 @ Idea 1
	1. mesh group update()
		1.1 if(visible)
		1.2 if(dirty)
		1.3 update inputs
		1.4 update mesh
			1.4.1 if(dirty)
			1.4.2 rottenTextureInput update
				1.4.2.1 if(dirty)
				1.4.2.2 SOB.getProperty("condition").getValue()
				1.4.2.3 calculate texture to select
				1.4.2.4 select the texture
				1.4.2.5 setClean()
			1.4.3 setClean()
		1.5 setClean()
UC 5 @ Idea 1
	1. EMD update()
		1.1 if(dirty)
		1.2 motionAnimationInput update()
			1.2.1 if(dirty)
			1.2.2 SOB.getProperty("motionState").getValue()
			1.2.3 calculate animation to select
			1.2.4 play animation
			1.2.5 setClean()
		1.3 setClean()